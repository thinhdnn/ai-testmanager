import { test as base, Page, expect } from '@playwright/test';

/**
 * {{name}} {{type}} fixture
 * {{#if description}}
 * {{description}}
 * {{/if}}
 */

{{!-- ===== TYPE: EXTEND (object with execute method) ===== --}}
{{#if (eq type "extend")}}
type {{exportName}} = {
  execute: () => Promise<void>;
};

type {{exportName}}Fixtures = {
  {{exportName}}: {{exportName}};
};

export const test = base.extend<{{exportName}}Fixtures>({
  {{exportName}}: async ({ page }: { page: Page }, use) => {
    const {{exportName}}: {{exportName}} = {
      execute: async () => {
        {{{content}}}
      },
    };

    await use({{exportName}});
  },
});

{{!-- ===== TYPE: EXTENDPAGE (inject page after setup) ===== --}}
{{else if (eq type "extendPage")}}
type {{exportName}}Fixtures = {
  {{exportName}}: Page;
};

export const test = base.extend<{{exportName}}Fixtures>({
  {{exportName}}: async ({ page }: { page: Page }, use) => {
    // Setup logic before exposing page
    async function setup(): Promise<void> {
      {{{content}}}
    }

    await setup();
    await use(page);
  },
});

{{!-- ===== TYPE: INLINE (manual function call) ===== --}}
{{else if (eq type "inline")}}
export async function {{exportName}}(page: Page): Promise<void> {
  {{{content}}}
}

{{!-- ===== TYPE: INLINEEXTEND (combines inline function with extend pattern) ===== --}}
{{else if (eq type "inlineExtend")}}
export async function {{exportName}}(page: Page): Promise<void> {
  {{{content}}}
}

type {{exportName}}Fixtures = {
  {{exportName}}: (page: Page) => Promise<void>;
};

export const test = base.extend<{{exportName}}Fixtures>({
  {{exportName}}: async ({}, use) => {
    await use({{exportName}});
  },
});

{{!-- ===== DEFAULT (fallback) ===== --}}
{{else}}
// No valid type provided
console.warn("Unsupported fixture type: '{{type}}'");
{{/if}}

export { expect } from '@playwright/test';
